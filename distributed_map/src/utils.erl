-module(utils).
-include("clusterdefs.hrl").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% These are often-used utility functions that are used by a few different modules.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%% Exports %%%%%%%%%%%%%%%%%%%%%%%%
% public functions
-export([register_server/1, register_client/1, get_clients/1, get_servers/1, get_clusters/0]).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% A generic function used the the register_server and register_client functions
% Note that any Erlang term can be used to register a name, so the client and server processes are named after a tuple.
% That tuple is in the form of {?SOFTWAREID,ClusterName,Type,UID}
% where ?SOFTWAREID is the unique SOFTWAREID name for the distributed map application contained in clusterdefs.hrl
% ClusterName is the user-supplied cluster name
% Type is either server or client, based on whether register_server or register_client is called
% and UID is a unique random number generated by the register_name function
% It tries at most twice to register the process using different random names.
register_name(Name,Pid) ->
	% seed the random number generator with the current time
	random:seed(now()),
	% get a random number uniformly distributed in the given range
	UID = random:uniform(999999),
	% take the given name list, add the UID to it, then convert the list into a tuple
	UName = erlang:list_to_tuple(Name ++ [UID]),
	% Try at most twice to register the tuple name
	% try to register the atom to the Pid
	case global:register_name(UName,Pid) of
		% if it works, then great
		yes -> {ok,UName};
		% if it fails then try again
		no ->
			UName2 = erlang:list_to_tuple(Name ++ [UID]),
			case global:register_name(UName2,Pid) of
				% if it work, then great
				yes -> {ok,UName2};
				% if it fails for a second time, then give up
				no -> no
			end
	end.

% register a server with the ClusterName.  It takes the PID from the process calling the function
register_server(ClusterName) ->
	% the Name of the server before the random UID is added
	Name = [?SOFTWAREID,ClusterName,server],
	register_name(Name,self()).

% register a client with the ClusterName.  It takes the PID from the process calling the function
register_client(ClusterName) ->
	% the Name of the client before the random UID is added
	Name = [?SOFTWAREID,ClusterName,client],
	register_name(Name,self()).

% a predicate filter used the extract the client or server processes belonging to a certain Type and ClusterName from all the registered names 
predicate_filter(Type, ClusterName) ->
	fun(RegisteredName) ->
			case RegisteredName of
				{?SOFTWAREID,ClusterName,Type,_} -> true;
				_ -> false
			end
	end.

% a predicate filter that extracts all of the cluster names from the globally registered names
predicate_filter(cluster) ->
	fun(RegisteredName) ->
			case RegisteredName of
				{?SOFTWAREID,_,_,_} -> true;
				_ -> false
			end
	end.

% get all of the clients belonging to the cluster "ClusterName"
get_clients(ClusterName) ->
	global:sync(),
	[global:whereis_name(X) || X <- lists:filter(predicate_filter(client,ClusterName),global:registered_names())].

% get all of the servers belonging to the cluster "ClusterName"
get_servers(ClusterName) ->
	global:sync(),
	[global:whereis_name(X) || X <- lists:filter(predicate_filter(server,ClusterName),global:registered_names())].

% get a list of all the distributed map clusters running on the erlang distributed computer
get_clusters() ->
	global:sync(),
	lists:usort([erlang:element(2,X) || X <- lists:filter(predicate_filter(cluster),global:registered_names())]).
